#! /usr/bin/env python

# Copyright (C) 2015 Dmitry Rodionov
# This file is part of my GSoC'15 project for Cuckoo Sandbox:
#    http://www.cuckoosandbox.org
# This software may be modified and distributed under the terms
# of the MIT license. See the LICENSE file for details.

# Edits by Federico (phretor) Maggi

import os
import sys
import pkgutil
import logging
import traceback
from datetime import datetime

from lib.core.config import Config
from lib.core.startup import create_folders, init_logging
from lib.core.packages import choose_package

from lib.common.results import upload_to_host
from lib.common.abstracts import Package, Auxiliary
from lib.common.constants import PATHS
from lib.common.exceptions import CuckooError, CuckooPackageError

from modules import auxiliary

log = logging.getLogger(__name__)

class Macalyser:
    """Cuckoo OS X analyzer.
    """

    target = ""
    target_artefacts = []
    config= []

    def prepare(self):
        """Prepare env for analysis."""
        # Create the folders used for storing the results.
        create_folders()

        # Initialize logging.
        init_logging()

        # Parse the analysis configuration file generated by the agent.
        self.parse_config("analysis.conf")

        # Setup machine time
        self.setup_machine_time()

    def run(self):
        """Run analysis.
        @return: operation status.
        """
        self.prepare()

        log.debug("Starting analyzer from: %s", os.getcwd())
        log.debug("Storing results at: %s", PATHS["root"])

        # Retrieve analysis package
        package = self.analysis_package_for_current_target()

        # Initialize analysis package
        self.initialize_package(package)

        # Setup and start auxiliary modules
        aux = self.setup_auxiliary_modules()

        # Start analysis package
        results = self.analysis(package)

        # Shutdown Auxiliary modules
        self.shutdown_auxiliary_modules(aux)

        # TODO: figure out a way to do this cleanly
        # shutdown_spawned_modules(results.procs_still_alive)

        # Done!
        self.complete(package)

    def complete(self, package):
        self.upload_artefacts(package)
        self.cleanup()

    def parse_config(self, config_name="analysis.conf"):
        self.config = Config(cfg=config_name)

    def analysis_package_for_current_target(self):
        # If no analysis package was specified at submission, we try to select
        # one automatically.
        if not self.config.package:
            log.debug("No analysis package specified, trying to detect "
                      "it automagically.")

            # If the analysis target is a file, we choose the package according
            # to the file format.
            if self.config.category == "file":
                package = choose_package(self.config.file_type,
                                         self.config.file_name)

            if not package:
                raise CuckooError("No valid package available for file "
                                  "type: {0}".format(self.config.file_type))

            log.info("Automatically selected analysis package \"%s\"", package)
        # Otherwise just select the specified package.
        else:
            package = self.config.package

        return package

    def initialize_package(self, package):
        # Generate the package path.
        package_name = "modules.packages.%s" % package

        # Try to import the analysis package.
        try:
            __import__(package_name, globals(), locals(), ["dummy"], -1)
        # If it fails, we need to abort the analysis.
        except ImportError:
            raise CuckooError("Unable to import package \"{0}\", does "
                              "not exist.".format(package_name))

        # Initialize the package parent abstract.
        Package()

        # Enumerate the abstract subclasses.
        try:
            package_class = Package.__subclasses__()[0]
        except IndexError as e:
            raise CuckooError("Unable to select package class "
                              "(package={0}): {1}".format(package_name, e))

        # Initialize the analysis package.
        pack = package_class(self.config.get_options())

    def setup_auxiliary_modules(self):
        # Initialize Auxiliary modules
        Auxiliary()
        prefix = auxiliary.__name__ + "."
        for loader, name, ispkg in pkgutil.iter_modules(
                auxiliary.__path__, prefix):
            if ispkg:
                continue

            # Import the auxiliary module.
            try:
                __import__(name, globals(), locals(), ["dummy"], -1)
            except ImportError as e:
                log.warning("Unable to import the auxiliary module "
                            "\"%s\": %s", name, e)

        # Walk through the available auxiliary modules.
        aux_enabled, aux_avail = [], []
        for module in Auxiliary.__subclasses__():
            # Try to start the auxiliary module.
            try:
                aux = module(self.config.get_options())
                aux_avail.append(aux)
                aux.start()
            except (NotImplementedError, AttributeError):
                log.warning("Auxiliary module %s was not implemented",
                            aux.__class__.__name__)
                continue
            except Exception as e:
                log.warning("Cannot execute auxiliary module %s: %s",
                            aux.__class__.__name__, e)
                continue
            finally:
                log.debug("Started auxiliary module %s",
                          aux.__class__.__name__)
                aux_enabled.append(aux)

    def setup_machine_time(self):
        # Set virtual machine clock.
        clock = datetime.strptime(self.config.clock, "%Y%m%dT%H:%M:%S")

        # Setting date and time.
        # TODO(phretor): check how to set seconds
        os.system("date {0}".format(clock.strftime("%m%d%H%M%y")))

        # TODO(phretor): add support for other than "file"
        if self.config.category == "file":
            self.target = os.path.join(os.environ["TEMP"] + os.sep,
                                       str(self.config.file_name))

    def analysis(self, package):
        try:
            pids = package.start(self.target)
        except NotImplementedError:
            raise CuckooError("The package \"{0}\" doesn't contain a run "
                              "function.".format(package))
        except CuckooPackageError as e:
            raise CuckooError("The package \"{0}\" start function raised an "
                              "error: {1}".format(package, e))
        except Exception as e:
            raise CuckooError("The package \"{0}\" start function encountered "
                              "an unhandled exception: "
                              "{1}".format(package, e))

        # Should we enforce timeout?
        if self.config.enforce_timeout:
            log.info("Enabled timeout enforce, running for the full timeout.")
            time.sleep(self.config.timeout)

        try:
            # Before finishing the analysis, the package can perform some
            # final operations through the finish() function.
            package.finish()
        except Exception as e:
            log.warning("The package \"%s\" finish function raised an "
                        "exception: %s", package, e)

    def shutdown_auxiliary_modules(self, aux):
        pass

    def shutdown_spawned_processes(self, procs):
        pass

    def upload_artefacts(self, package):
        try:
            # Upload files the package created to package_files in the 
            # results folder to host
            package_files = package.package_files()
            if package_files != None:
                for p in package_files:
                    upload_to_host(
                        p[0], os.path.join("package_files", p[1]));
        except Exception as e:
            log.warning("The package \"%s\" package_files function raised an "
                        "exception: %s", package, e)


    def cleanup(self):
        pass

Analyzer = Macalyser

if __name__ == "__main__":
    success = False
    error = ""

    try:
        # Initialize the main analyzer class.
        analyzer = Analyzer()

        # Run it and wait for the response.
        success = analyzer.run()

    # This is not likely to happen.
    except KeyboardInterrupt:
        error = "Keyboard Interrupt"

    # If the analysis process encountered a critical error, it will raise a
    # CuckooError exception, which will force the termination of the analysis.
    # Notify the agent of the failure. Also catch unexpected exceptions.
    except Exception as e:
        # Store the error.
        error_exc = traceback.format_exc()
        error = str(e)

        # Just to be paranoid.
        if len(log.handlers):
            log.exception(error_exc)
        else:
            sys.stderr.write("{0}\n".format(error_exc))

    # Once the analysis is completed or terminated for any reason, we report
    # back to the agent, notifying that it can report back to the host.
    #finally:
    #    # Establish connection with the agent XMLRPC server.
    #    server = xmlrpclib.Server("http://127.0.0.1:8000")
    #    server.complete(success, error, PATHS["root"])
